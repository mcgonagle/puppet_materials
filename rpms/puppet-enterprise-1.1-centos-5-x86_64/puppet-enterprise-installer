#! /bin/bash

#==========================================================
# Copyright @ 2011 Puppet Labs, LLC
# Redistribution prohibited.
# Address: 411 NW Park Ave., Suite 500 / Portland, OR 97209
# Phone: (877) 575-9775
# Email: info@puppetlabs.com
#
# Please refer to the LICENSE.pdf file included
# with the Puppet Enterprise distribution
# for licensing information.
#==========================================================

#===[ Summary ]=========================================================

# This program installs Puppet Enterprise. Run this file to start the
# interactive installation or run with a "-h" option to display help.

#===[ Conventions ]=====================================================

# VARIABLES
#
# Variable names starting with "q_" are sanitized user answers to
# questions asked by the `ask` function.
#
# Variable names starting with "t_" are transient variables for use
# within a function. For example, "t_ask__name" is a transient variable
# for storing a "name" within the "ask" function. This convention is
# necessary because all POSIX sh variables are globals and there's no
# way to localize the scope of variables to prevent functions from
# stomping over each other's state.
#
# Variable names in all capital letters are globals that are
# intentionally shared between different functions.
#
# This file can be sourced into a shell for use as a library.

#===[ Functions ]=======================================================

# Stop executioning the program, after cleaning up.
exception_handler() {
    display_newline
    display_major_separator
    display_newline
    display_failure "Cancelling installation"
    quit
}

# Invoke the exception_handler on CTRL-C or "set -e" errors.
register_exception_handler() {
    trap exception_handler INT TERM EXIT
}

# Remove the exception handler.
unregister_exception_handler() {
    trap - INT TERM EXIT
}

# Display a multiline string, because we can't rely on `echo` to do the right thing.
#
# Arguments:
# 1. Text to display.
display() {
    display_nonewline "${1?}\n"
}

# Display a multiline string without a trailing newline.
#
# Arguments:
# 1. Text to display.
display_nonewline() {
    printf -- "${1?}"
}

# Create the workdir, a temporary directory for use by the program, if needed.
prepare_workdir() {
    if [ -z "${WORKDIR:-""}" -o ! -d "${WORKDIR:-""}" ]; then
        # NOTE: The `mktemp` command is not POSIX, but is supported by most UNIX variants:
        WORKDIR=`mktemp -t -d tmp.puppet-enterprise-installer.XXXXXX`
    fi
}

# Remove the workdir, a temporary directory used by this installer:
remove_workdir() {
    if [ ! -z "${WORKDIR:-""}" ]; then
        if [ -d "${WORKDIR?}" ]; then
            rm -rf "${WORKDIR?}"
        fi
        unset WORKDIR
    fi
}

# Exit the installer and remove the workdir if it exists.
#
# Arguments:
# 1. Exit value, defaults to 0.
quit() {
    unregister_exception_handler
    remove_workdir
    exit "${1:-"0"}"
}

# Display a newline
display_newline() {
    display ''
}

# Display an error message to STDERR, but do not exit.
#
# Arguments:
# 1. Message to display.
display_error() {
    echo "!! ERROR: ${1?}" | display_wrapped_text 0 1>&2
    display_newline 1>&2
}

# Display an error message to STDERR and exit the program.
#
# Arguments:
# 1. Error message to display.
display_failure() {
    display_error "${1?}"
    display_footer
    quit 1
}

# Display a failure within "prepare_platform".
#
# Arguments:
# 1. Error message to display.
display_platform_failure() {
    IS_FAILURE=y

    # Set default columns if needed
    if [ -z "${PLATFORM_COLUMNS:-""}" ]; then
        PLATFORM_COLUMNS=72
    fi

    display_failure "${1?}"
}

# Display usage information, optionally display error message.
#
# Arguments:
# 1. Error message to display. Optional.
display_usage() {
    t_display_usage__error="${1:-""}"

    display "
USAGE: $(basename "${0?}") [-a ANSWER_FILE] [-A ANSWER_FILE] [-D] [-h] [-l LOG_FILE] [-n] [-s ANSWER_FILE]

OPTIONS:

    -a ANSWER_FILE
        Read answers from file and quit with error if an answer is missing.
    -A ANSWER_FILE
        Read answers from file and prompt for input if an answer is missing.
    -D
        Display debugging information.
    -h
        Display this help.
    -l LOG_FILE
        Log commands and results to file.
    -n
        Run in 'noop' mode; show commands that would have been run
        during installation without running them
    -s ANSWER_FILE
        Save answers to file and quit without installing."

    if [ ! -z "${t_display_usage__error?}" ]; then
        display_newline
        display_failure "${t_display_usage__error?}"
    else
        display_footer
        quit
    fi
}

# Display a step in the installation process.
#
# Arguments:
# 1. Description of the step, e.g. "PERFORM INSTALLATION"
# 2. Display newline afterwards? Defaults to 'y'.
display_step() {
    t_display_step__description="${1?}"
    t_display_step__newline="${2:-"y"}"

    if [ -z "${DISPLAY_STEP__NUMBER:-""}" ]; then
        DISPLAY_STEP__NUMBER=1
    else
        DISPLAY_STEP__NUMBER=$(( 1 + ${DISPLAY_STEP__NUMBER?} ))
    fi

    display_newline
    display_minor_separator
    display_newline
    display "STEP ${DISPLAY_STEP__NUMBER?}: ${t_display_step__description?}"

    if [ y = "${t_display_step__newline?}" ]; then
        display_newline
    fi
}

# Display the name of a product and its description.
#
# Arguments:
# 1. Name of product, e.g. "Puppet Strings"
# 2. Description of the product, e.g. "Enterprise-quality strings for your marionettes."
display_product() {
    t_display_product__name="${1?}"
    t_display_product__description="${2?}"

    display "
-> ${t_display_product__name?}

$(echo "${t_display_product__description?}" | display_wrapped_text)
"
}

# Display the comment line.
#
# Arguments:
# 1. Comment to display.
display_comment() {
    display "## ${1?}"
}

# Display the fake commaned.
#
# Arguments:
# 1. Command to display, e.g., "ls -la"
display_placeholder() {
    t_display_placeholder__message="++ ${1?}"

    display "${t_display_placeholder__message?}"
    if has_logfile; then
        echo "${t_display_placeholder__message?}" >> "${LOGFILE?}"
    fi
}

# Display a major separator line.
display_major_separator() {
    if [ -z "${t_display_major_separator:-""}" ]; then
        t_display_major_separator="$(display_extend_text =)"
    fi

    display "${t_display_major_separator?}"
}

# Display a minor separator line.
display_minor_separator() {
    if [ -z "${t_display_minor_separator:-""}" ]; then
        t_display_minor_separator="$(display_extend_text -)"
    fi

    display "${t_display_minor_separator?}"
}

# Display the header.
display_header() {
    display_major_separator
    display_newline
    display "Puppet Enterprise v$(cat "$(installer_dir)/VERSION") installer"
}

# Display the footer.
display_footer() {
    display_newline
    display_major_separator
}

# Display a line of the given character extended to the full width of the terminal.
#
# Arguments:
# 1. Character to display, e.g. "="
display_extend_text() {
    prepare_platform

    echo "${1?}" "${PLATFORM_COLUMNS?}" | awk '{ result=""; for (i = 1; i <= $2; i++) { printf($1) } }'
}

# Display wrapped, indented text..
#
# Arguments:
# 1. Spaces to use for the initial line's indentation, e.g. 0
# 2. Spaces to use for the Subsequent lines' indentation, e.g. 4
# 3. Maximum width of the indented text before it's wrapped. Defaults to a sensible value.
#
# Example:
#   echo "Hello world!" | display_wrapped_text 4 2 4
display_wrapped_text() {
    t_display_wrapped_text__initial="${1:-"3"}"
    t_display_wrapped_text__subsequent="${2:-"3"}"
    t_display_wrapped_text__maxlength="${3:-""}"

    prepare_platform

    # Set default maxlength value based on terminal width
    if [ -z "${t_display_wrapped_text__maxlength?}" ]; then
        t_display_wrapped_text__maxlength="$(( ${PLATFORM_COLUMNS?} - 4 ))"
    fi

    # If no awk is available, just use cat
    if [ -z "${PLATFORM_AWK:-""}" ]; then
        cat
        return
    fi

    "${PLATFORM_AWK?}" -vmaxlength="${t_display_wrapped_text__maxlength?}" -vinitial="${t_display_wrapped_text__initial?}" -vsubsequent="${t_display_wrapped_text__subsequent?}" '
        function set_indent() {
            if (is_initial == 1)
                spacing = initial
            else
                spacing = subsequent

            if (spacing > 0)
                indent = sprintf(("%" spacing "s"), " ")
            else
                indent = ""
        }

        BEGIN {
            if (! maxlength)
                maxlength = 72

            if (! initial)
                initial = 0

            if (! subsequent)
                subsequent = 0

            buffer = ""
            is_initial = 1
            current = 0
        }

        {
            if (NF) {
                for (i = 1; i <= NF ; i++) {
                    if (buffer == "") {
                        buffer = $i
                    } else {
                        set_indent()

                        if (length(indent) + length(buffer) + length($i) + 1 <= maxlength) {
                            buffer = ( buffer " " $i )
                        } else {
                            if (is_initial == 1) {
                                is_initial = 0
                            }
                            printf("%s%s\n", indent, buffer)
                            buffer = $i
                        }
                    }
                 }
          } else {
              buffer = ""
              print
          }
        }

        END {
            if (length(buffer) > 0)
                set_indent()
                printf("%s%s", indent, buffer)
        }
    '
}

# Display a list of missing vendor packages.
#
# Arguments:
# 1. String containing a list of missing vendor packages separated by spaces.
display_missing_vendor_packages() {
    echo "Required vendor packages missing on computer:" | display_wrapped_text
    display_newline
    printf "${1?}" | sed 's/^/   * /g'
    display_newline
    display_newline
}

# Display the "certdnsnames" derived from the given hostnames. Will also add entries for "puppet" and the "puppet.$DOMAIN_NAME" for each domain name specified.
#
# Arguments:
# 1. Colon-separated list of hostnames to derive the "certdnsnames" from, e.g. "foo:bar".
display_certdnsnames() {
    t_display_certdnsnames__result=

    for t_display_certdnsnames__hostname in "puppet" $(echo "${1?}" | sed 's/:/ /g'); do
        t_display_certdnsnames__base_hostname=`echo "${t_display_certdnsnames__hostname?}" | cut -s -d. -f1`
        t_display_certdnsnames__domain=`echo "${t_display_certdnsnames__hostname?}" | cut -s -d. -f2-`
        if [ -z "${t_display_certdnsnames__domain?}" ]; then
            t_display_certdnsnames__result="${t_display_certdnsnames__result?}\n${t_display_certdnsnames__hostname}"
        else
            t_display_certdnsnames__result="${t_display_certdnsnames__result?}\n${t_display_certdnsnames__hostname}\n${t_display_certdnsnames__base_hostname}"
            if [ "puppet" != "${t_display_certdnsnames__base_hostname?}" ]; then
                t_display_certdnsnames__result="${t_display_certdnsnames__result?}\npuppet.${t_display_certdnsnames__domain}"
            fi
        fi
    done

    printf "${t_display_certdnsnames__result?}" | ${PLATFORM_EGREP?} '\w' | sort | uniq | xargs | sed 's/[[:space:]]/:/g'
}

# Display a question, make the user answer it, and set a variable with their answer.
#
# Arguments:
# 1. Name of the variable to export, e.g. "q_favorite_color"
# 2. Question text to display, e.g. "What's your favorite color?"
# 3. Kind of question, e.g. "Yn" to show a 'Y/n' prompt that defaults to 'yes', "yN" to show a y/N prompt that defaults to 'no', "String" for a manditory string response, "StringOrBlank" for an optional string response.
# 4. Default answer, optional. Currently only supported for "String" questions.
ask() {
    t_ask__name="${1?}"
    t_ask__question="${2?}"
    t_ask__kind="${3?}"
    t_ask__default="${4:-""}"

    t_ask__message="?? ${t_ask__question?} "
    case "${t_ask__kind?}" in
        Yn)
            t_ask__message="${t_ask__message?}[Y/n] "
            ;;
        yN)
            t_ask__message="${t_ask__message?}[y/N] "
            ;;
        StringOrBlank)
            t_ask__message="${t_ask__message?}[Default: (blank)] "
            ;;
        String*)
            if [ ! -z "${t_ask__default?}" ]; then
                t_ask__message="${t_ask__message?}[Default: ${t_ask__default?}] "
            fi
            ;;
        *)
            display_failure "Invalid question kind: ${t_ask__kind?}"
            ;;
    esac

    # Try to load the answer from an existing variable, e.g. given name "q" look at variable "$q".
    eval t_ask__answered=\$"${t_ask__name:-""}"

    # Was the variable "$q" defined before the question was run, like if the answer file defined it?
    eval '[ -n "${'"${t_ask__name:-}"'}" ] && t_ask__defined=0 || t_ask__defined=1'

    t_ask__success=n
    until [ y = "${t_ask__success?}" ]; do
        echo "${t_ask__message?}" | display_wrapped_text 0
        display_nonewline " "
        if [ 0 = "${t_ask__defined?}" ]; then
            t_ask__response="${t_ask__answered?}"
            display "${t_ask__response?}"
            unset t_ask__answered
        else
            if [ 0 != "${t_ask__defined?}" -a y = "${IS_ANSWER_REQUIRED:-""}" ]; then
                display_newline
                display_failure "Could not find response for above question in answer file. (Variable needed: ${t_ask__name?})"
            fi
            read -r t_ask__response
        fi

        case "${t_ask__kind?}" in
            Yn)
                if [ -z "${t_ask__response?}" -o y = "${t_ask__response?}" -o Y = "${t_ask__response?}" ]; then
                    t_ask__answer=y
                    t_ask__success=y
                elif [ n = "${t_ask__response?}" -o N = "${t_ask__response?}" ]; then
                    t_ask__answer=n
                    t_ask__success=y
                else
                    display_error 'Answer must be either "y", "n" or <ENTER> for "y"'
                fi
                ;;
            yN)
                if [ y = "${t_ask__response?}" -o Y = "${t_ask__response?}" ]; then
                    t_ask__answer=y
                    t_ask__success=y
                elif [ -z "${t_ask__response?}" -o n = "${t_ask__response?}" -o N = "${t_ask__response?}" ]; then
                    t_ask__answer=n
                    t_ask__success=y
                else
                    display_error 'Answer must be either "y", "n" or <ENTER> for "n"'
                fi
                ;;
            String)
                if [ -z "${t_ask__response?}" -a ! -z "${t_ask__default?}" ]; then
                    t_ask__answer="${t_ask__default?}"
                    t_ask__success=y
                elif [ ! -z ${t_ask__response?} ]; then
                    t_ask__answer="${t_ask__response?}"
                    t_ask__success=y
                else
                    display_error 'Answer must be a string'
                fi
                ;;
            StringForceLowerCase)
                if [ -z "${t_ask__response?}" -a ! -z "${t_ask__default?}" ]; then
                    t_ask__answer="$(echo "${t_ask__default?}" | tr '[A-Z]' '[a-z]')"
                    t_ask__success=y
                elif [ ! -z ${t_ask__response?} ]; then
                    t_ask__answer="$(echo "${t_ask__response?}" | tr '[A-Z]' '[a-z]')"
                    t_ask__success=y
                else
                    display_error 'Answer must be a string'
                fi
                ;;
            StringWithoutCommas)
                if [ -z "${t_ask__response?}" -a ! -z "${t_ask__default?}" ]; then
                    t_ask__answer="${t_ask__default?}"
                    t_ask__success=y
                elif [ ! -z ${t_ask__response?} ] && echo "${t_ask__response?}" | grep -qv '[, ]'; then
                    t_ask__answer="${t_ask__response?}"
                    t_ask__success=y
                else
                    display_error 'Answer must be a string without any commas (use : to separate names)'
                fi
                ;;
            StringOrBlank)
                t_ask__answer="${t_ask__response?}"
                t_ask__success=y
                ;;
            *)
                ;;
        esac
    done

    eval "${t_ask__name?}=${t_ask__answer?}"
}

# Display the command to run and execute it if not running in noop mode.
#
# Arguments:
# 1. Command to execute, e.g. "ls -la"
run() {
    t_run__command="${1?}"
    t_run__message="** ${t_run__command?}"

    display "${t_run__message?}"
    if has_logfile; then
        echo "${t_run__message?}" >> "${LOGFILE?}"
    fi
    if is_noop; then
        return 0
    else
        if has_logfile; then
            ( eval "${t_run__command?}" ) 2>&1 | tee -a "${LOGFILE?}"
        else
            ( eval "${t_run__command?}" )
        fi
        return $?
    fi
}

# Prepare variables storing platform information:
# * PLATFORM_NAME : Name of the platorm, e.g. "centos".
# * PLATFORM_TAG : Tag representing the platform, release and architecture, e.g. "centos-5-i386"
# * PLATFORM_RELEASE : Release version, e.g. "10.10".
# * PLATFORM_ARCHITECTURE : Architecture, e.g. "i386".
# * PLATFORM_PACKAGING : Name of local packaging system, e.g. "dpkg".
# * PLATFORM_AWK : Path to the desired awk, e.g. "nawk".
# * PLATFORM_HOSTNAME : Hostnmae of this machine, e.g. "myhost.mycompany.com".
# * PLATFORM_COLUMNS : Number of columns on the terminal or a reasonable default.
prepare_platform() {
    # Don't do detection if within a failure to avoid loop
    if [ y = "${IS_FAILURE:-""}" ]; then
        return
    fi

    prepare_workdir

    # NONPORTABLE

    # Awk
    if [ -z "${PLATFORM_AWK:-""}" ]; then
        for command in gawk nawk awk; do
            if type "${command?}" > /dev/null 2>&1; then
                PLATFORM_AWK="${command?}"
                break
            fi
        done

        if [ -z "${PLATFORM_AWK:-""}" ]; then
            display_platform_failure "Can't find \"awk\" in PATH -- please install it before continuing"
        fi
    fi

    # JJM Default to grep -E to preserve existing behavior.
    # Note, this function gets called over and over, so we need to be a bit defensive if the variable is already set.
    if [ -z "${PLATFORM_EGREP}" ]; then
        PLATFORM_EGREP='grep -E'
    fi

    # Name and release
    if [ -z "${PLATFORM_NAME:-""}" -o -z "${PLATFORM_RELEASE:-""}" ]; then
        CLIENT_ONLY='false'
        # First try identifying using lsb_release.  This takes care of Ubuntu (lsb-release is part of ubuntu-minimal).
        if type lsb_release > /dev/null 2>&1; then
            t_prepare_platform=`lsb_release -icr 2>&1`

            PLATFORM_NAME="$(printf "${t_prepare_platform?}" | ${PLATFORM_EGREP?} '^Distributor ID:' | cut -s -d: -f2 | sed 's/[[:space:]]//' | tr '[[:upper:]]' '[[:lower:]]')"

            # Sanitize name for unusual platforms
            case "${PLATFORM_NAME?}" in
                redhatenterpriseserver | redhatenterpriseclient | redhatenterpriseas | enterpriseenterpriseserver )
                    PLATFORM_NAME=rhel
                    ;;
                'suse linux' )
                    PLATFORM_NAME=sles
                ;;
            esac

            # Release
            PLATFORM_RELEASE="$(printf "${t_prepare_platform?}" | ${PLATFORM_EGREP?} '^Release:' | cut -s -d: -f2 | sed 's/[[:space:]]//g')"

            # Sanitize release for unusual platforms
            case "${PLATFORM_NAME?}" in
                centos | rhel )
                    # Platform uses only number before period as the release, e.g. "CentOS 5.5" is release "5"
                    PLATFORM_RELEASE="$(printf "${PLATFORM_RELEASE?}" | cut -d. -f1)"
                    ;;
            esac
        # Test for Solaris.
        elif [ "x$(uname -s)" = "xSunOS" ]; then
            PLATFORM_NAME="solaris"
            t_platform_release="$(uname -r)"
            # JJM We get back 5.10 but we only care about the right side of the decimal.
            PLATFORM_RELEASE="${t_platform_release##*.}"
            PLATFORM_EGREP='egrep'
        # Test for RHEL variant. RHEL, CentOS, OEL
        elif [ -f /etc/redhat-release -a -r /etc/redhat-release -a -s /etc/redhat-release ]; then
            # Oracle Enterprise Linux 5.3 and higher identify the same as RHEL
            if grep -qi 'red hat enterprise' /etc/redhat-release; then
                PLATFORM_NAME=rhel
            elif grep -qi 'centos' /etc/redhat-release; then
                PLATFORM_NAME=centos
            fi
            # Release - take first digit after ' release ' only.
            PLATFORM_RELEASE="$(sed 's/.*\ release\ \([[:digit:]]\).*/\1/g' /etc/redhat-release)"
        # Test for Debian releases
        elif [ -f /etc/debian_version -a -r /etc/debian_version -a -s /etc/debian_version ]; then
            t_prepare_platform__debian_version=`cat /etc/debian_version`

            if printf "${t_prepare_platform__debian_version?}" | ${PLATFORM_EGREP?} '^[[:digit:]]'; then
                PLATFORM_NAME=debian
                PLATFORM_RELEASE="$(printf "${t_prepare_platform__debian_version?}" | sed 's/\..*//')"
            fi
        elif [ -f /etc/SuSE-release -a -r /etc/SuSE-release ]; then
            t_prepare_platform__suse_version=`cat /etc/SuSE-release`

            if printf "${t_prepare_platform__suse_version?}" | ${PLATFORM_EGREP?} 'Enterprise Server'; then
                PLATFORM_NAME=sles
                t_version=`/bin/cat /etc/SuSE-release | grep VERSION | sed 's/^VERSION = \(\d*\)/\1/' `
                t_patchlevel=`cat /etc/SuSE-release | grep PATCHLEVEL | sed 's/^PATCHLEVEL = \(\d*\)/\1/' `
                PLATFORM_RELEASE="${t_version}.${t_patchlevel}"
            fi
        fi
    fi

    case "${PLATFORM_NAME?}" in
        centos | rhel )
            if [ "${PLATFORM_RELEASE?}" = '4' ] ; then
                CLIENT_ONLY='true'
            fi
            ;;
        solaris)
            CLIENT_ONLY='true'
            ;;
    esac

    if [ -z "${PLATFORM_NAME:-""}" -o -z "${PLATFORM_RELEASE:-""}" ]; then
        display_platform_failure "Unknown platform"
    fi

    # Packaging
    if [ -z "${PLATFORM_PACKAGING:-""}" ]; then
        case "${PLATFORM_NAME?}" in
            centos | rhel | sles )
                PLATFORM_PACKAGING=rpm
                ;;
            ubuntu | debian )
                PLATFORM_PACKAGING=dpkg
                ;;
            solaris )
                PLATFORM_PACKAGING=pkgadd
                ;;
            *)
                display_platform_failure "Unknown packaging system for platform: ${PLATFORM_NAME?}"
                ;;
        esac
    fi

    # Architecture
    if [ -z "${PLATFORM_ARCHITECTURE:-""}" ]; then
        case "${PLATFORM_NAME?}" in
            solaris )
                PLATFORM_ARCHITECTURE="$(uname -p)"
                ;;
            *)
                PLATFORM_ARCHITECTURE="`uname -m`"
                ;;
        esac
        if [ x86_64 = "${PLATFORM_ARCHITECTURE?}" ]; then
            case "${PLATFORM_NAME?}" in
                ubuntu | debian )
                    PLATFORM_ARCHITECTURE=amd64
                    ;;
            esac
        elif [ i686 = "${PLATFORM_ARCHITECTURE?}" ]; then
            PLATFORM_ARCHITECTURE=i386
        fi
    fi

    # Tag
    if [ -z "${PLATFORM_TAG:-""}" ]; then
        PLATFORM_TAG="${PLATFORM_NAME?}-${PLATFORM_RELEASE?}-${PLATFORM_ARCHITECTURE?}"
    fi

    # Columns
    if [ -z "${PLATFORM_COLUMNS:-""}" ]; then
        PLATFORM_COLUMNS="$(stty size 2>&1 | cut -s -d" " -f2)"
        if ! (echo $PLATFORM_COLUMNS | ${PLATFORM_EGREP?} '^[[:digit:]]+$') > /dev/null 2>&1; then
            PLATFORM_COLUMNS=72
        fi
    fi

    # Hostname
    if [ -z "${PLATFORM_HOSTNAME:-""}" ]; then
        PLATFORM_HOSTNAME=`uname -n`
    fi
}

# Fail unless the current user has root privileges.
prepare_user() {
    # NONPORTABLE
    case "${PLATFORM_NAME?}" in
        solaris)
            # JJM BASHISM NONPORTABLE
            if [ ! "0" = "${EUID?}" ]; then
                display_failure "The installer must be run by a user with \"root\" privileges."
            fi
            ;;
        *)
            if [ ! "0" = "$(id -u)" ]; then
                display_failure "The installer must be run by a user with \"root\" privileges."
            fi
            ;;
    esac
}

# Make a backup copy of the file. Creates the backup in the same directory with a timestamp and ".bak" suffix.
#
# Arguments:
# 1. File to backup.
backup_file() {
    t_backup_file__source="${1?}"
    t_backup_file__target="${t_backup_file__source?}.`date '+%Y%m%dT%H%M%S'`.bak"

    case "${PLATFORM_NAME?}" in
        solaris)
            t_cp='cp -p -r'
            ;;
        *)
            t_cp='cp -a'
            ;;
    esac

    if [ -e "${t_backup_file__source?}" ]; then
        run "${t_cp?} ${t_backup_file__source?} ${t_backup_file__target?}"
    fi
}

# Add package to queue for installation.
#
# Arguments:
# 1. Package name to install, eg. "puppet-dashboard".
enqueue_package() {
    if [ ! -z "${PACKAGES_REQUIRED:-""}" ]; then
        PACKAGES_REQUIRED="${PACKAGES_REQUIRED?}\n${1?}"
    else
        PACKAGES_REQUIRED="${1?}"
    fi
}

# Display queued packages that aren't installed, one package per line.
missing_queued_packages() {
    prepare_workdir
    prepare_platform

    # All packages required:
    t_missing_queued_packages__required="${WORKDIR?}/packages_required"
    # Packages currently installed:
    t_missing_queued_packages__installed="${WORKDIR?}/packages_installed"
    # Required packages that need to be installed:
    t_missing_queued_packages__needed="${WORKDIR?}/packages_needed"

    if [ "x${PLATFORM_NAME}" = "xsolaris" ]; then
        printf "${PACKAGES_REQUIRED:-""}\n" | sort | uniq > "${t_missing_queued_packages__required?}"
    else
        printf "${PACKAGES_REQUIRED:-""}" | sort | uniq > "${t_missing_queued_packages__required?}"
    fi

    # NONPORTABLE
    case "${PLATFORM_PACKAGING?}" in
        rpm)
            rpm -qa --queryformat '%{NAME}\n' `cat "${t_missing_queued_packages__required?}"` | sort | uniq > "${t_missing_queued_packages__installed?}"
            comm -23 "${t_missing_queued_packages__required?}" "${t_missing_queued_packages__installed?}" > "${t_missing_queued_packages__needed?}"
            cat "${t_missing_queued_packages__needed?}"
            ;;
        dpkg)
            dpkg-query --show --showformat '${Package} ${Status}\n' `cat "${t_missing_queued_packages__required?}"` 2>&1 | "${PLATFORM_AWK?}" '/ installed$/ { print $1 }' | sort | uniq > "${t_missing_queued_packages__installed?}"
            comm -23 "${t_missing_queued_packages__required?}" "${t_missing_queued_packages__installed?}" > "${t_missing_queued_packages__needed?}"
            cat "${t_missing_queued_packages__needed?}"
            ;;
        pkgadd)
            # JJM Obtain the packages required _and_ already installed.
            # First, obtain the list of all packages installed.  Since we're using comm -23, this is OK.  (We don't need to query for the specific packages we require)
            pkginfo | awk '{print $2}' | sort | uniq > "${t_missing_queued_packages__installed?}"
            # Next, obtain the list of packages required, but NOT already installed
            comm -23 "${t_missing_queued_packages__required?}" "${t_missing_queued_packages__installed?}" > "${t_missing_queued_packages__needed?}"
            # Finally, output the file
            cat "${t_missing_queued_packages__needed?}"
            ;;
        *)
            display_failure "Don't know how to install packages on platform: ${PLATFORM_NAME?}"
            ;;
    esac
}

# Install the packages queued up by the `enqueue_package`.
install_queued_packages() {
    t_install_queued_packages__cmd=""
    t_install_queued_packages__local="${WORKDIR?}/packages_needed_local"
    t_install_queued_packages__remote="${WORKDIR?}/packages_needed_remote"
    t_install_queued_packages__noask="${WORKDIR?}/noask"

    prepare_workdir
    prepare_platform

    rm -f "${t_install_queued_packages__local?}"
    rm -f "${t_install_queued_packages__remote?}"

    for t_install_queued_packages__package_name in `missing_queued_packages | xargs`; do
        if t_install_queued_packages__package_file=`package_name_to_file ${t_install_queued_packages__package_name?}`; then
            echo "${t_install_queued_packages__package_file?}" >> "${t_install_queued_packages__local?}"
        else
            echo "${t_install_queued_packages__package_name?}" >> "${t_install_queued_packages__remote?}"
        fi
    done

    if [ -s "${t_install_queued_packages__remote?}" ]; then
        t_install_queued_packages__cmd="$(xargs < "${t_install_queued_packages__remote?}")"

        # NONPORTABLE
        case "${PLATFORM_PACKAGING?}" in
            rpm)
                case "${PLATFORM_NAME?}" in
                    sles)
                        t_install_queued_packages__cmd="zypper install -y ${t_install_queued_packages__cmd?}"
                        ;;
                    *)
                        t_install_queued_packages__cmd="yum install -y ${t_install_queued_packages__cmd?}"
                        ;;
                esac
                ;;
            dpkg)
                t_install_queued_packages__cmd="apt-get update -qq || true ; DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${t_install_queued_packages__cmd?}"
                ;;
            pkgadd)
                display_failure "Cannot locate the following packages: ${t_install_queued_packages__cmd}"
                ;;
            *)
                display_failure "Don't know how to install packages from repositories on platform: ${PLATFORM_NAME?}"
                ;;
        esac

        display_comment 'Installing packages from repositories...'
        if ! run "${t_install_queued_packages__cmd?}"; then
            display_newline
            display_major_separator
            display_newline
            display_failure "Package installation failed"
        fi

        if ! is_noop; then
            # Double-check that packages really were installed, mostly for "yum" which doesn't return error codes
            PACKAGES_REQUIRED="$(cat "${t_install_queued_packages__remote?}")"
            t_install_queued_packages__missing="$(missing_queued_packages | xargs)"
            if [ ! -z "${t_install_queued_packages__missing?}" ]; then
                display_newline
                display_major_separator
                display_newline
                display_failure "Could not install required packages from your operating system's repository--this may be due to incorrect repository settings. You must install the following packages before you can install Puppet Enterprise: ${t_install_queued_packages__missing?}"
            fi
        fi
    fi

    if [ -s "${t_install_queued_packages__local?}" ]; then
        t_install_queued_packages__cmd="$(xargs < "${t_install_queued_packages__local?}")"

        # NONPORTABLE
        case "${PLATFORM_PACKAGING?}" in
            rpm)
                t_install_queued_packages__cmd="rpm -ivh ${t_install_queued_packages__cmd?}"
                ;;
            dpkg)
                t_install_queued_packages__cmd="DEBIAN_FRONTEND=noninteractive dpkg -i ${t_install_queued_packages__cmd?}"
                ;;
            pkgadd)
                # Write the noask file to a temporary directory
                # please see man -s 4 admin for details about this file:
                # http://www.opensolarisforum.org/man/man4/admin.html
                #
                # The key thing we don't want to prompt for are conflicting files.
                # The other nocheck settings are mostly defensive to prevent prompts
                # We _do_ want to check for available free space and abort if there is
                # not enough
                cat <<'ENDofNOASKfile' > "${t_install_queued_packages__noask}"
mail=
# Overwrite already installed instances
instance=overwrite
# Don't bother checking for partially installed packages
partial=nocheck
# Don't bother checking the runlevel
runlevel=nocheck
# Don't bother checking package dependencies (We take care of this)
idepend=nocheck
rdepend=nocheck
# DO check for available free space and abort if there isn't enough
space=quit
# Don't check for setuid files.
setuid=nocheck
# Don't check if files conflict with other packages
conflict=nocheck
# We have no action scripts.  Don't check for them.
action=nocheck
# Install to the default base directory.
basedir=default
ENDofNOASKfile
                # JJM This is _not_ as mis-matched quote, we're building up a long command in the for loop.
                t_install_queued_packages__cmd_buf="bash -ec '"
                for t_install_queued_packages__pkg in ${t_install_queued_packages__cmd?}; do
                    t_install_queued_packages__cmd_buf="${t_install_queued_packages__cmd_buf?} gzip -dc ${t_install_queued_packages__pkg?} | pkgadd -G -a ${t_install_queued_packages__noask?} -n -d /dev/stdin all;"
                done
                t_install_queued_packages__cmd_buf="${t_install_queued_packages__cmd_buf?}'"
                t_install_queued_packages__cmd="${t_install_queued_packages__cmd_buf?}"
                ;;
            *)
                display_failure "Don't know how to install packages from files on platform: ${PLATFORM_NAME?}"
                ;;
        esac

        display_comment 'Installing packages from files...'
        if ! run "${t_install_queued_packages__cmd?}"; then
            display_newline
            display_major_separator
            display_newline
            display_failure "Could not install packages from files; see messages above for cause."
        fi
    fi

    unset PACKAGES_REQUIRED
}

# Display the package filename for the given package name. Returns exit value 1 if no package file was found.
#
# Arguments
# 1. Package name, e.g. "puppet-facter"
package_name_to_file() {
    t_package_name_to_file__dir="`platform_package_dir`"

    prepare_platform

    # NONPORTABLE
    case "${PLATFORM_PACKAGING?}" in
        rpm)
            t_package_name_to_file__file="`ls -1t "${t_package_name_to_file__dir?}"/*.rpm | grep -v '.src.rpm' | grep -v -- '-debuginfo-' | ${PLATFORM_EGREP?} "/${1?}-[[:digit:]]" | head -n1`"
            ;;
        dpkg)
            t_package_name_to_file__file="`ls -1t "${t_package_name_to_file__dir?}"/*.deb | ${PLATFORM_EGREP?} "/${1?}_[[:digit:]].+_(all|${PLATFORM_ARCHITECTURE?})\.deb" | head -n1`"
            ;;
        pkgadd)
            t_package_name_to_file__file="`ls -1t "${t_package_name_to_file__dir?}"/*.pkg.gz | ${PLATFORM_EGREP?} "/${1?}-[0-9]+" | head -n1`"
            ;;
        *)
            display_failure "Don't know how to map package names to files on platform: ${PLATFORM_NAME?}"
            ;;
    esac

    if [ ! -z "${t_package_name_to_file__file?}" ]; then
        echo "${t_package_name_to_file__file?}"
        return 0
    else
        # Not found
        return 1
    fi
}

# Display the package name for the given filename. Returns exit value 1 if no package name was found
#
# Arguments
# 1. filename, e.g. pe-facter-1.5.8-1.el5.noarch.rpm
package_file_to_name() {
    t_package_file_to_name__dir="`platform_package_dir`"
    case "${PLATFORM_PACKAGING?}" in
        rpm)
            t_package_file_to_name__name="$(rpm -q --qf '%{NAME}' -p "${t_package_file_to_name__dir?}/${1?}")"
            ;;
        dpkg)
            t_package_file_to_name__name="$(dpkg -I "${t_package_file_to_name__dir?}/${1?}"  | awk '/Package:/ {print $NF}')"
            ;;
        *)
            display_failure "Don't know how to map package files to names on platform: ${PLATFORM_NAME?}"
            ;;
    esac
    if [ ! -z "${t_package_file_to_name__name?}" ]; then
        echo "${t_package_file_to_name__name?}"
        return 0
    else
        # Not found
        return 1
    fi
}

# Return the PE dependencies for a given package
#
# Arguments:
# 1. filename, e.g. pe-facter-1.5.8-1.el5.noarch.rpm
# Returns:
# newline-separated list of package names
package_pe_deps() {
    case "${PLATFORM_PACKAGING?}" in
        rpm)
            # packages starting with 'pe-'
            # and not containing '(' or ')' or ending in '-mmn' (virtual pkg provided by httpd)
            t_package_pe_deps__deps="$(rpm -qR -p "$(platform_package_dir)/${1?}" | awk '/^pe-/ { if ( $1 !~ /.+[()]/ && $1 !~ /.+-mmn/ ) print $1 }')"
            ;;
        dpkg)
            # packages starting with 'pe-'
            # and not of the form pe-lib.*-ruby.* (virtual pkgs provided by pe-libruby.*)
            t_package_pe_deps__deps="$(dpkg-deb --showformat='${Depends}' -W "$(platform_package_dir)/${1?}" | sed "s/, /\\n/g" | awk '/^pe-/ { if ( $1 !~ /pe-lib.+-ruby.*/ ) print $1}')"
            ;;
        *)
            display_failure "Don't know how to determine dependencies on platform: ${PLATFORM_NAME?}"
            ;;
    esac

    if [ ! -z "${t_package_pe_deps__deps?}" ]; then
        echo "${t_package_pe_deps__deps?}"
        return 0
    else
        # No PE dependencies found.
        # This is to be expected sometimes.
        return 0
    fi

}

# Display path to this installer. Optionally override this by exporting INSTALLER_DIR environment variable.
installer_dir() {
    if [ -z "${INSTALLER_DIR:-""}" ]; then
        INSTALLER_DIR="$(dirname "${0?}")"
    fi

    echo "${INSTALLER_DIR?}"
}

# Display platform's package path, e.g. "packages/centos-5-x86_64".
platform_package_dir() {
    prepare_platform

    echo "$(installer_dir)/packages/${PLATFORM_TAG?}"
}

# Append the line to the buffer.
#
# Write out the contents of the buffer using "filebuffer_write".
#
# Arguments:
# 1. Line
filebuffer_append() {
    prepare_workdir

    echo "${1?}" >> "${WORKDIR?}/filebuffer"
}

# Write the contents of the buffer to a file if active, and display to screen.
#
# Add contents to the buffer using "filebuffer_append".
#
# Arguments:
# 1. Filename
filebuffer_write() {
    if is_noop; then
        display_comment "Would have generated file \"${1?}\" with contents:"
    else
        display_comment "Generated file \"${1?}\" with contents:"
    fi

    display_newline
    sed -e 's/^/   /' < "${WORKDIR?}/filebuffer"
    display_newline

    if ! is_noop; then
        t_filebuffer_write__directory="$(dirname "${1?}")"
        if [ ! -d "${t_filebuffer_write__directory?}" ]; then
            run "mkdir -p ${t_filebuffer_write__directory?}" > /dev/null
        fi

        if [ -s "${1?}" ]; then
            backup_file "${1?}"
        fi

        cat "${WORKDIR?}/filebuffer" > "${1?}"
    fi

    filebuffer_clear
}

# Clear the buffer.
filebuffer_clear() {
    rm -f "${WORKDIR?}/filebuffer"
}

# Load the answers from a file. The file is just a shell script that we source.
#
# Arguments:
# 1. File to load answers from.
load_answers() {
    t_load_answers__file="${1?}"

    if [ -f "${t_load_answers__file?}" ]; then
        if [ '.' = "$(dirname "${t_load_answers__file?}")" -a ! "./" = "$( echo "${t_load_answers__file?}" | cut -c 1-2)" ]; then
            # Some shells can only source files if given a path.
            t_load_answers__file="./${t_load_answers__file?}"
        fi

        display_step 'READ ANSWERS FROM FILE'
        display_comment "Reading answers from file: ${t_load_answers__file?}"
        . "${t_load_answers__file?}"
    else
        display_failure "Can't find answers file: ${t_load_answers__file?}"
    fi
}

# Running in noop mode? Return 0 if true.
is_noop() {
    if [ y = "${IS_NOOP:-""}" ]; then
        return 0
    else
        return 1
    fi
}

# Was a logfile specified?
has_logfile() {
    if [ ! -z "${LOGFILE:-""}" ]; then
        return 0
    else
        return 1
    fi
}

# Is the package installed? Returns 0 for true, 1 for false.
#
# Arguments:
# 1. Name of package.
is_package_installed() {
    prepare_platform

    # NONPORTABLE
    case "${PLATFORM_PACKAGING?}" in
        rpm)
            (rpm -qi "${1?}") > /dev/null 2>&1
            return $?
            ;;
        dpkg)
            (dpkg-query --show --showformat '${Package}:${Status}\\n' "${1?}" 2>&1 | grep ' installed') > /dev/null
            return $?
            ;;
        *)
            display_failure "Don't know how to check if package is installed on this platform."
            ;;
    esac
}

# Start the named service if needed.
#
# 1. Name of service .
bounce_service() {
    prepare_platform

    # NONPORTABLE
    case "${PLATFORM_NAME?}" in
        centos | rhel | ubuntu | sles)
            if ! (service "${1?}" status) > /dev/null 2>&1; then
                run "service ${1?} start"
            else
                run "service ${1?} restart"
            fi
            ;;
        debian)
            if ! (invoke-rc.d "${1?}" status) > /dev/null 2>&1; then
                run "invoke-rc.d ${1?} start"
            else
                run "invoke-rc.d ${1?} restart"
            fi
            ;;
        *)
            display_failure "Don't know how to restart service on this platform."
            ;;
    esac
}

# Enable the named service at boot.
#
# 1. Name of service .
enable_service() {
    prepare_platform

    # NONPORTABLE
    case "${PLATFORM_NAME?}" in
        centos | rhel | ubuntu | sles)
            run "chkconfig ${1?} on" || :
            ;;
        debian)
            # This will not override existing links. --daniel 2011-01-28
            run "update-rc.d ${1?} defaults 80 20" || :
            ;;
        *)
            display_failure "Don't know how to enable a service on this platform."
            ;;
    esac
}

# Install a symlink for the given file into "/usr/local/bin".
#
# Arguments:
# 1. Filename fragment, e.g. "sbin/puppetca" will be symlinked to "/usr/local/bin/puppetca".
install_symlink() {
    if [ ! -d "/usr/local/bin/" ]
    then
        display "\"/usr/local/bin/\" does not exist, creating."
        run "mkdir -p /usr/local/bin/"
    fi

    for f in "$@"; do
        t_install_symlink_basename="/usr/local/bin/`basename ${f?}`"
        if [ -e "${t_install_symlink_basename}" ]
        then
            display_error "\"${t_install_symlink_basename} already exists, unable to create symlink."
            display "Remove \"${t_install_symlink_basename}\" and run: ln -s /opt/puppet/${f?} ${t_install_symlink_basename}"
        else
            run "ln -nsf /opt/puppet/${f?} ${t_install_symlink_basename}"
        fi
    done
}

# Install util files into opt bindir
#
# Arguments: None
install_utils_to_bin() {
    for f in ${INSTALLER_DIR}/util/*; do
        cp "${f}" /opt/puppet/bin/
    done
}

#===[ Main ]============================================================

if [ "puppet-enterprise-installer" = "$(basename "${0?}")" ]; then

    #---[ Environment ]-----------------------------------------------------

    # Installing via sudo may not add required path components
    PATH=$PATH:/usr/sbin:/usr/bin:/sbin:/bin

    #---[ Paranoia ]--------------------------------------------------------

    # Exit immediately if a simple command exits with a non-zero status:
    set -e

    #---[ Debug ]-----------------------------------------------------------

    # Display execution trace information for debugging and save it to a file:
    if ! (echo $- | grep x) > /dev/null; then
        i=1
        for item in "$@"; do
            if [ '-D' = "${item?}" ]; then
                logfile=`mktemp -t puppet-enterprise-installer.log.XXXXXXXXXX`
                sh -x "${0?}" "$@" 2>&1 | tee "${logfile?}"
                echo "!! Wrote debugging information to: ${logfile?}"
                quit
            fi
            i=$(( ${i?} + 1 ))
        done
    fi

    #---[ Prepare ]---------------------------------------------------------

    # Catch CTRL-C and "set -e" errors:
    register_exception_handler

    # Setup "PLATFORM_*" variables:
    prepare_platform

    #---[ Process command-line options ]------------------------------------

    ANSWER_FILE_TO_LOAD=
    ANSWER_FILE_TO_SAVE=
    IS_ANSWER_REQUIRED=n
    LOGFILE=
    IS_NOOP=n

    while getopts a:A:Dhl:nqs: name; do
        case "$name" in
            a)
                ANSWER_FILE_TO_LOAD="${OPTARG?}"
                IS_ANSWER_REQUIRED=y
                ;;
            A)
                ANSWER_FILE_TO_LOAD="${OPTARG?}"
                IS_ANSWER_REQUIRED=n
                ;;
            D)
                # Do nothing, this is handled for us during preparation
                ;;
            h)
                display_header
                display_usage
                ;;
            l)
                LOGFILE="${OPTARG?}"
                if [ -s "${LOGFILE?}" ]; then
                    # Clear the file so it can be appended throughout the installer's execution
                    echo -n > "${LOGFILE?}"
                fi
                ;;
            n)
                IS_NOOP=y
                ;;
            s)
                ANSWER_FILE_TO_SAVE="${OPTARG?}"
                ;;
            ?)
                display_header
                display_usage "Illegal option specified"
                ;;
        esac
    done

    #---[ Announce installation ]-------------------------------------------

    # Announce installer:
    display_header

    # Prepare the installer variable:
    installer_dir > /dev/null

    # Ensure platform is supported:
    if [ -d "`platform_package_dir`" ]; then
        display "for ${PLATFORM_TAG?}"
    else
        display_major_separator
        display_newline
        display_failure "Can't find packages for platform: ${PLATFORM_TAG?}"
    fi

    # Check user:
    prepare_user

    # Load answers if specified:
    if [ ! -z "${ANSWER_FILE_TO_LOAD?}" ]; then
        load_answers "${ANSWER_FILE_TO_LOAD?}"
    fi

    #---[ Interview user ]--------------------------------------------------

    display_step 'SELECT AND CONFIGURE PRODUCTS' n
    display_newline
    if [ 'false' =  "${CLIENT_ONLY?}" ]; then
        echo "This installer will offer to install puppet master, Puppet Dashboard and puppet agent." | display_wrapped_text
        display_newline

        display_product 'puppet master' 'The puppet master service manages the configurations of a group of puppet agent nodes. It can optionally integrate with Puppet Dashboard for reporting and node classification.'
        ask q_puppetmaster_install 'Install puppet master?' Yn
        if [ y = "${q_puppetmaster_install?}" ]; then
            ask q_puppetmaster_certname "Puppet master's \"certname\"?" StringForceLowerCase "${PLATFORM_HOSTNAME?}" # This question to be removed per Issue #5558, with q_puppetmaster_certname set to "puppet". (Should this variable still be settable via an answer file?)
            ask q_puppetmaster_certdnsnames "Puppet master's certified hostnames (colon-separated list of hostnames and FQDNs which resolve to this server)?" StringWithoutCommas "$(display_certdnsnames "${q_puppetmaster_certname?}")"
            ask q_puppetmaster_use_dashboard_reports "Send reports to Puppet Dashboard?" Yn
            ask q_puppetmaster_use_dashboard_classifier "Use Puppet Dashboard as an external node classifier?" Yn
            if [ y = "${q_puppetmaster_use_dashboard_reports?}" -o y = "${q_puppetmaster_use_dashboard_classifier?}" ]; then
                ask q_puppetmaster_dashboard_hostname "Puppet Dashboard hostname to use?" String localhost
                ask q_puppetmaster_dashboard_port "Puppet Dashboard port to use?" String 3000
            fi
        fi

        display_product 'Puppet Dashboard' 'The Puppet Dashboard application collects reports from a puppet master server, presents node information in a web interface, and provides a graphical environment in which to group and modify puppet agent nodes.'
        ask q_puppetdashboard_install 'Install Puppet Dashboard?' Yn
        if [ y = "${q_puppetdashboard_install?}" ]; then
            ask q_puppetdashboard_httpd_port "Port to run Puppet Dashboard on?" String 3000
            # We change the default answer depending upon whether MySQL is already installed
            if is_package_installed mysql-server; then
                t_q_puppetdashboard_database_install_answer=yN
            else
                t_q_puppetdashboard_database_install_answer=Yn
            fi
            ask q_puppetdashboard_database_install "Install a new MySQL database server for use with the Puppet Dashboard from your operating system's repository?" "${t_q_puppetdashboard_database_install_answer}"
            if [ y = "${q_puppetdashboard_database_install?}" ]; then
                ask q_puppetdashboard_database_root_password "What password should the 'root' user have on this new database?" String
            else
                display_newline
                echo "Puppet Dashboard requires a MySQL database and an appropriately privileged user."

                ask q_puppetdashboard_database_remote "Is your existing MySQL database server running on a remote host?" Yn
                if [ y = "${q_puppetdashboard_database_remote?}" ]; then
                    ask q_puppetdashboard_database_host 'Database server hostname?' String localhost
                    ask q_puppetdashboard_database_port 'Database port?' String 3306
                fi
            fi
            ask q_puppetdashboard_database_name 'Database name?' String dashboard
            ask q_puppetdashboard_database_user "Database user$( if [ n = "${q_puppetdashboard_database_install?}" ]; then echo " (must have all privileges on the database '${q_puppetdashboard_database_name?}')"; fi)?" String dashboard
            ask q_puppetdashboard_database_password 'Database user password?' String
            # If the database is not to be installed, display the SQL snippet using their settings.
            if [ y != "${q_puppetdashboard_database_install?}" ]; then
                display_newline
                echo "If the database and user have not yet been created on your database server, please log in as a privileged user and set them up manually. E.g.:" | display_wrapped_text
                printf -- '%s' "

                CREATE DATABASE ${q_puppetdashboard_database_name} CHARACTER SET utf8;
                CREATE USER '${q_puppetdashboard_database_user}'@'localhost' IDENTIFIED BY '${q_puppetdashboard_database_password}';
                GRANT ALL PRIVILEGES ON ${q_puppetdashboard_database_name}.* TO '${q_puppetdashboard_database_user}'@'localhost';
                "

            fi
        fi
    else
        display_newline
        echo "${PLATFORM_NAME?} ${PLATFORM_RELEASE?} only supports agent installation"
        q_puppetmaster_install='n'
        q_puppetdashboard_install='n'
    fi

    display_product 'puppet agent' 'The puppet agent service receives configurations from a puppet master server and applies them to this computer.'
    ask q_puppetagent_install 'Install puppet agent?' Yn
    if [ y = "${q_puppetagent_install?}" ]; then
        ask q_puppetagent_certname "Unique identifier (\"certname\") for this puppet agent node?" StringForceLowerCase "${PLATFORM_HOSTNAME?}"
        ask q_puppetagent_server "Puppet master hostname to connect to?" String `if [ y = "${q_puppetmaster_install?}" ] && [ ! -z "${q_puppetmaster_certname?}" ]; then echo ${q_puppetmaster_certname?}; else echo puppet; fi`
        ask q_puppetagent_pluginsync "Use \"pluginsync\" to copy plugins from the puppet master?" Yn
    fi

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" -o y = "${q_puppetagent_install?}" ]; then
        if [ ! "x${PLATFORM_NAME?}" = "xsolaris" ]; then
            display_product 'Development libraries' 'The development libraries allow you to do things like install Ruby gems that have native extensions (compiled C code).'
            ask q_rubydevelopment_install 'Install the Ruby development libraries? (Requires GCC)' yN
        fi
    fi

    #...[ Vendor packages ].................................................

    # Enqueue vendor packages based on user's answers...

    # NONPORTABLE
    case "${PLATFORM_NAME?}" in
        centos | rhel)
            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                if [ y = "${q_rubydevelopment_install?}" ]; then
                    enqueue_package 'gcc'
                    enqueue_package 'glibc-devel'
                fi
            fi

            enqueue_package 'net-tools'
            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'apr'
                enqueue_package 'apr-util'
                if [ "x6" = "x${PLATFORM_RELEASE?}" ]; then
                    # JJM apr-util-ldap is new in RHEL6
                    enqueue_package 'apr-util-ldap'
                    # JJM mailcap is required for /etc/mime.types
                    enqueue_package 'mailcap'
                fi
            fi

            if [ y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'mysql'

                if [ y = "${q_puppetdashboard_database_install?}" ]; then
                    enqueue_package 'mysql-server'
                fi
            fi
            ;;
        sles)
            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                if [ y = "${q_rubydevelopment_install?}" ]; then
                    enqueue_package 'gcc'
                    enqueue_package 'glibc-devel'
                fi
            fi

            enqueue_package 'net-tools'
            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'libapr1'
                enqueue_package 'libapr-util1'
            fi

            if [ y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'mysql-client'

                if [ y = "${q_puppetdashboard_database_install?}" ]; then
                    enqueue_package 'mysql'
                fi
            fi
            ;;
        ubuntu | debian)
            enqueue_package 'hostname'
            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'libreadline5'

                if [ y = "${q_rubydevelopment_install?}" ]; then
                    enqueue_package 'build-essential'
                fi
            fi

            if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'file'
                enqueue_package 'libmagic1'
                enqueue_package 'libpcre3'
                enqueue_package 'mime-support'
                enqueue_package 'libapr1'
                if [ debian = "${PLATFORM_NAME?}" ]; then 
                    enqueue_package 'libcap1'
                fi 
                enqueue_package 'libaprutil1'
                if [ ubuntu =  "${PLATFORM_NAME?}" ]; then
                    enqueue_package 'libaprutil1-dbd-sqlite3'
                    enqueue_package 'libaprutil1-ldap'
                fi
            fi

            if [ y = "${q_puppetdashboard_install?}" ]; then
                enqueue_package 'mysql-client'
                enqueue_package 'mysql-common'

                if [ y = "${q_puppetdashboard_database_install?}" ]; then
                    # Pre-seed the values of the MySQL server "root" password, otherwise "apt-get/dpkg" will prompt us for the values.
                    echo "mysql-server-5.1 mysql-server/root_password password ${q_puppetdashboard_database_root_password:-""}" | debconf-set-selections
                    echo "mysql-server-5.1 mysql-server/root_password_again password ${q_puppetdashboard_database_root_password:-""}" | debconf-set-selections

                    enqueue_package 'mysql-server'
                fi
            fi
            ;;
        solaris)
            # JJM There are no vendor packages to install on Solaris
            :
            ;;
        *)
            display_failure "Don't know how to install vendor packages on this platform."
            ;;
    esac

    # Determine which vendor packages are missing
    t_main_missing_vendor_packages="$(missing_queued_packages)"

    # Continue interview
    if [ ! -z "${ANSWER_FILE_TO_SAVE?}" ]; then
        # When saving answers, always prompt user to install vendor packages
        display_product 'Vendor Packages' "The Puppet product suite may require additional packages from your operating system vendor. You will need to either install these yourself, or allow them to be automatically installed from your operating system vendor's package repositories."
        if [ ! -z "${t_main_missing_vendor_packages?}" ]; then
            display_missing_vendor_packages "${t_main_missing_vendor_packages?}"
        fi
        ask q_vendor_packages_install 'Allow automatic installation of these packages?' Yn
    elif [ ! -z "${t_main_missing_vendor_packages?}" ]; then
        # When running, only prompt user to install vendor packages if needed
        display_product 'Vendor Packages' "The installer has detected that Puppet Enterprise requires additional packages from your operating system vendor's repositories, and can automatically install them. If you choose not to install these packages automatically, the installer will exit so you can install them manually."
        display_missing_vendor_packages "${t_main_missing_vendor_packages?}"
        ask q_vendor_packages_install 'Install these packages automatically?' Yn
        if [ ! y = "${q_vendor_packages_install?}" ]; then
            display_failure "You must manually install the above packages before installing Puppet Enterprise."
        fi
    else
        # Set default value
        q_vendor_packages_install="${q_vendor_packages_install:-"n"}"
    fi

    #...[ Convenience links ]...............................................

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" ]; then
        display_product 'Convenience Links' 'The selected Puppet software will be installed into "/opt/puppet", which may not be included in your default shell PATH. For ease of use, this installer can create symbolic links to these executables in "/usr/local/bin".'
        ask q_puppet_symlinks_install "Setup symbolic links to Puppet executables in \"/usr/local/bin\"?" Yn
    else
        q_puppet_symlinks_install=n
    fi

    #---[ Save ]------------------------------------------------------------

    if [ ! -z "${ANSWER_FILE_TO_SAVE?}" ]; then
        display_step 'SAVE ANSWERS'
        q_install=y
        set | ${PLATFORM_EGREP?} '^q_' > ${ANSWER_FILE_TO_SAVE?}
        display_comment "Saved answers to file: ${ANSWER_FILE_TO_SAVE?}"
        display_newline
        display_major_separator
        quit
    fi

    #---[ Quit early ]------------------------------------------------------

    if [ ! y = "${q_puppetmaster_install?}" -a ! y = "${q_puppetagent_install?}" -a ! y = "${q_puppetdashboard_install?}" ]; then
        display_newline
        display_major_separator
        display_newline
        display_failure "Nothing selected for installation"
    fi

    #---[ Confirm ]---------------------------------------------------------

    display_step 'CONFIRM PLAN'

    ask q_install 'Perform installation?' Yn
    if [ ! y = "${q_install?}" ]; then
        display_newline
        display_major_separator
        display_newline
        display "!! Installation cancelled"
        display_newline
        display_major_separator
        quit 1
    fi

    #---[ Generate "puppet.conf" ]------------------------------------------

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" ]; then
        display_step 'GENERATE PUPPET CONFIGURATION'

        filebuffer_append '[main]'
        filebuffer_append '    vardir = /var/opt/lib/pe-puppet'
        filebuffer_append '    logdir = /var/log/pe-puppet'
        filebuffer_append '    rundir = /var/run/pe-puppet'
        filebuffer_append '    modulepath = /etc/puppetlabs/puppet/modules'
        filebuffer_append '    user = pe-puppet'
        filebuffer_append '    group = pe-puppet'

        if [ y = "${q_puppetmaster_install?}" ]; then
            filebuffer_append ''
            filebuffer_append '[master]'
            filebuffer_append "    certname = ${q_puppetmaster_certname?}"
            filebuffer_append "    certdnsnames = $(display_certdnsnames "${q_puppetmaster_certdnsnames?}")"
            if [ y = "${q_puppetmaster_use_dashboard_reports?}" ]; then
                filebuffer_append '    reports = http, store'
                filebuffer_append "    reporturl = http://${q_puppetmaster_dashboard_hostname?}:${q_puppetmaster_dashboard_port?}/reports/"
            else
                filebuffer_append '    reports = store'
            fi
            if [ y = "${q_puppetmaster_use_dashboard_classifier?}" ]; then
                filebuffer_append '    node_terminus  = exec'
                filebuffer_append '    external_nodes = /etc/puppetlabs/puppet-dashboard/external_node'
            fi
            filebuffer_append '    ssl_client_header = SSL_CLIENT_S_DN'
            filebuffer_append '    ssl_client_verify_header = SSL_CLIENT_VERIFY'
        fi

        if [ y = "${q_puppetagent_install?}" ]; then
            filebuffer_append ''
            filebuffer_append '[agent]'
            filebuffer_append "    certname = ${q_puppetagent_certname?}"
            filebuffer_append "    server = ${q_puppetagent_server?}"
            filebuffer_append '    report = true'
            filebuffer_append '    classfile = $vardir/classes.txt'
            filebuffer_append '    localconfig = $vardir/localconfig'
            filebuffer_append '    graph = true'
            if [ y = "${q_puppetagent_pluginsync?}" ]; then
                filebuffer_append '    pluginsync = true'
            fi
        fi

        # Create configuration in temporary file so user isn't asked if package's configuration file should replace it.
        filebuffer_write '/etc/puppetlabs/puppet/puppet.conf.tmp'
    fi

    #---[ Enqueue our packages ]--------------------------------------------

    # NONPORTABLE
    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
        case "${PLATFORM_NAME?}" in
            centos | rhel | sles)
                enqueue_package 'pe-ruby'
                enqueue_package 'pe-ruby-irb'
                enqueue_package 'pe-ruby-libs'
                enqueue_package 'pe-ruby-rdoc'
                enqueue_package 'pe-ruby-ri'
                enqueue_package 'pe-ruby-shadow'
                enqueue_package 'pe-rubygems'

                if [ y = "${q_rubydevelopment_install?}" ]; then
                    enqueue_package 'pe-ruby-devel'
                fi
                ;;
            ubuntu | debian)
                enqueue_package 'pe-ruby1.8'
                enqueue_package 'pe-libruby1.8'
                enqueue_package 'pe-ri1.8'
                enqueue_package 'pe-ruby-shadow'
                enqueue_package 'pe-rubygems'
                enqueue_package 'pe-rubygems1.8'

                if [ y = "${q_rubydevelopment_install?}" ]; then
                    enqueue_package 'pe-ruby1.8-dev'
                fi
                ;;
            solaris)
                enqueue_package 'pup-ruby'
                enqueue_package 'pup-openssl'
                enqueue_package 'pup-rubygems'
                ;;
            *)
                display_failure "Don't know how to install Ruby on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetagent_install?}" ]; then
        case "${PLATFORM_NAME?}" in
            centos | rhel | sles)
                enqueue_package 'pe-facter'
                enqueue_package 'pe-puppet'
                enqueue_package 'pe-rubygem-puppet-module'
                enqueue_package 'pe-augeas'
                enqueue_package 'pe-augeas-libs'
                enqueue_package 'pe-ruby-augeas'
                enqueue_package 'pe-ruby-ldap'
                ;;
            ubuntu | debian)
                enqueue_package 'pe-facter'
                enqueue_package 'pe-puppet-agent'
                enqueue_package 'pe-puppet-common'
                enqueue_package 'pe-puppet-module-tool'
                enqueue_package 'pe-libaugeas0'
                enqueue_package 'pe-augeas-tools'
                enqueue_package 'pe-ruby-augeas'
                enqueue_package 'pe-augeas-lenses'
                enqueue_package 'pe-ruby-ldap'
                ;;
            solaris)
                enqueue_package 'pup-facter'
                enqueue_package 'pup-puppet'
                ;;
            *)
                display_failure "Don't know how to install Puppet on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
        case "${PLATFORM_NAME?}" in
            centos | rhel)
                enqueue_package 'pe-httpd'
                # JJM Starting with RHEL6 pe-httpd-tools is a new package not in previous versions
                if [ "x6" = "x${PLATFORM_RELEASE}" ]; then
                    enqueue_package 'pe-httpd-tools'
                fi
                enqueue_package 'pe-httpd-passenger'
                enqueue_package 'pe-mod_ssl'
                enqueue_package 'pe-rubygem-rack'
                enqueue_package 'pe-rubygem-rake'
                ;;
            sles)
                enqueue_package 'pe-httpd'
                enqueue_package 'pe-httpd-passenger'
                enqueue_package 'pe-mod_ssl'
                enqueue_package 'pe-rubygem-rack'
                enqueue_package 'pe-rubygem-rake'
                ;;
            ubuntu | debian)
                enqueue_package 'pe-httpd-mpm-worker'
                enqueue_package 'pe-httpd-common'
                enqueue_package 'pe-httpd'
                enqueue_package 'pe-httpd-bin'
                enqueue_package 'pe-httpd-utils'
                enqueue_package 'pe-httpd-passenger'
                enqueue_package 'pe-rack'
                enqueue_package 'pe-rake'
                ;;
            *)
                display_failure "Don't know how to install HTTPD on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppetmaster_install?}" ]; then
        case "${PLATFORM_NAME?}" in
            centos | rhel | sles)
                enqueue_package 'pe-puppet-server'
                enqueue_package 'pe-rubygem-activesupport'
                enqueue_package 'pe-rubygem-activeresource'
                enqueue_package 'pe-rubygem-activerecord'
                enqueue_package 'pe-rubygem-actionpack'
                enqueue_package 'pe-rubygem-actionmailer'
                enqueue_package 'pe-rubygem-rails'
                ;;
            ubuntu | debian)
                enqueue_package 'pe-puppet-master'
                ;;
            *)
                display_failure "Don't know how to install puppet master on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppetdashboard_install?}" ]; then
        enqueue_package 'pe-puppet-dashboard'
        enqueue_package 'pe-ruby-mysql'
    fi

    #---[ Install packages ]------------------------------------------------

    display_step 'INSTALL PACKAGES'

    install_queued_packages

    # Replace the package's configuration file.
    run "mv /etc/puppetlabs/puppet/puppet.conf.tmp /etc/puppetlabs/puppet/puppet.conf"

    #---[ Setup packages ]--------------------------------------------------

    if [ y = "${q_puppetmaster_install?}" ]; then
        display_comment 'Setting up puppet master...'

        # FIXME PACKAGING should packages create these directories and set ownership?
        run 'mkdir -p /var/opt/lib/pe-puppetmaster/public/ /var/opt/lib/pe-puppetmaster/public/tmp /var/opt/lib/pe-puppet/'
        run 'chown -R pe-puppet:pe-puppet /var/opt/lib/pe-puppet/ /var/log/pe-puppet/'

        run "/opt/puppet/bin/puppet cert --generate ${q_puppetmaster_certname?} --certdnsnames '${q_puppetmaster_certname?}:puppet' --verbose --color=false|| true"

        filebuffer_append \
"Listen 8140
<VirtualHost *:8140>
    SSLEngine on
    SSLCipherSuite SSLv2:-LOW:-EXPORT:RC4+RSA
    SSLCertificateFile      /etc/puppetlabs/puppet/ssl/certs/${q_puppetmaster_certname?}.pem
    SSLCertificateKeyFile   /etc/puppetlabs/puppet/ssl/private_keys/${q_puppetmaster_certname?}.pem
    SSLCertificateChainFile /etc/puppetlabs/puppet/ssl/ca/ca_crt.pem
    SSLCACertificateFile    /etc/puppetlabs/puppet/ssl/ca/ca_crt.pem
    # CRL checking should be enabled; if you have problems with Apache complaining about the CRL, disable the next line
    SSLCARevocationFile     /etc/puppetlabs/puppet/ssl/ca/ca_crl.pem
    SSLVerifyClient optional
    SSLVerifyDepth  1
    SSLOptions +StdEnvVars

    # The following client headers allow the same configuration to work with Pound.
    RequestHeader set X-SSL-Subject %{SSL_CLIENT_S_DN}e
    RequestHeader set X-Client-DN %{SSL_CLIENT_S_DN}e
    RequestHeader set X-Client-Verify %{SSL_CLIENT_VERIFY}e

    RackAutoDetect On
    DocumentRoot /var/opt/lib/pe-puppetmaster/public/
    <Directory /var/opt/lib/pe-puppetmaster/>
        Options None
        AllowOverride None
        Order allow,deny
        allow from all
    </Directory>
</VirtualHost>"
        filebuffer_write '/etc/puppetlabs/httpd/conf.d/puppetmaster.conf'

# This is done to make it possible to trigger a license
# check during master startup from config.ru, invoked by Passenger, in the
# PE environment. To be removed when we insert a hook in Puppet to enable
# this more cleanly.

        filebuffer_append \
'# A "config.ru", for use with every Rack-compatible webserver.
# SSL needs to be handled outside this, though.

$0 = "master"

# If you want debugging, uncomment the following line:
# ARGV << "--debug"

ARGV += ["--rack"]
require "puppet/application/master"

class Puppet::Application::Master
  unless defined?(setup_original) then
    alias :setup_original :setup
  end

  def setup
    result = setup_original

    # This must run after the original setup method because we depend on it
    # completing all our setup steps to be able to call these next methods...
    if Puppet::SSL::CertificateAuthority.ca? then
      begin
        require "puppet/util/license"
        Puppet::Util::License.display_license_status
      rescue Exception => e
        Puppet.crit("Loading the license code in the master failed:\n#{e}")
        Puppet.crit("Something is very wrong with your install; please reinstall\n" +
                    "or otherwise contact Puppet Labs for support!")
        # ...and that is sufficient. --daniel 2011-01-18
      end
    end

    result
  end
end

run Puppet::Application[:master].run'
        filebuffer_write '/var/opt/lib/pe-puppetmaster/config.ru'

        if [ y = "${q_puppetmaster_use_dashboard_classifier?}" ]; then
            filebuffer_append "#!/opt/puppet/bin/ruby
require 'yaml'
require 'uri'
require 'net/http'

BASE=\"http://${q_puppetmaster_dashboard_hostname?}:${q_puppetmaster_dashboard_port?}\"
NODE = ARGV.first

url = URI.parse(\"#{BASE}/nodes/#{NODE}\")
req = Net::HTTP::Get.new(url.path, 'Accept' => 'text/yaml')
res = Net::HTTP.start(url.host, url.port) {|http| http.request(req) }

case res
when Net::HTTPSuccess
    puts res.body
    exit 0
else
    STDERR.puts \"Error: #{res.code} #{res.message.strip}\n#{res.body}\"
    exit 1
end "
            filebuffer_write '/etc/puppetlabs/puppet-dashboard/external_node'
            run 'chmod a+rx /etc/puppetlabs/puppet-dashboard/external_node'
            run 'chmod a+rX /etc/puppetlabs/puppet-dashboard'
        fi

        run 'mkdir -p /etc/puppetlabs/puppet/modules/helloworld/lib'
        run 'mkdir -p /etc/puppetlabs/puppet/modules/helloworld/manifests'
        filebuffer_append "\
class helloworld {
  notify { 'example':
    message => 'Hello World!',
  }
}"
        filebuffer_write '/etc/puppetlabs/puppet/modules/helloworld/manifests/init.pp'

        # FIXME PACKAGING Should the packages set the permissions correctly?
        run 'chown -R pe-puppet:pe-puppet /var/opt/lib/pe-puppet/ /var/opt/lib/pe-puppetmaster/ /var/log/pe-puppet/'
    fi

    if [ y = "${q_puppetagent_install?}" ]; then
        display_comment 'Checking the agent certificate name detection...'
        if run "/opt/puppet/bin/puppet agent --configprint certname --color=false"; then
            display_comment 'Setting up puppet agent...'
            if [ ! y = "${q_puppetmaster_install?}" ]; then
                run "/opt/puppet/bin/puppet agent --no-daemonize --verbose --onetime --test --color=false|| true"
            fi
        else
            display_failure 'The agent certificate name was incorrect; please check'
            display_failure 'that your system can correctly resolve its own FQDN in DNS.'
        fi

        # NONPORTABLE
        case "${PLATFORM_NAME?}" in
            centos | rhel | sles)
                bounce_service 'pe-puppet'
                ;;
            ubuntu | debian)
                run "printf \"START=true\nDAEMON_OPTS=''\n\" > /etc/default/pe-puppet-agent"
                bounce_service 'pe-puppet-agent'
                ;;
            solaris)
                cat <<'ENDofSMFxmlCONFIG' > /var/svc/manifest/network/puppetagent.xml
<?xml version="1.0"?>
<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">

<!-- Original puppet manifest: Luke Kanies - puppetlabs.com -->

<service_bundle type='manifest' name='puppetagent'>

  <service
    name='network/puppetagent'
    type='service'
    version='1'>

    <create_default_instance enabled='false'/>
    <single_instance/>

    <dependency name='config-file'
      grouping='require_all'
      restart_on='none'
      type='path'>
      <service_fmri value='file:///etc/puppetlabs/puppet/puppet.conf'/>
    </dependency>

    <dependency name='loopback'
      grouping='require_all'
      restart_on='error'
      type='service'>
      <service_fmri value='svc:/network/loopback:default'/>
    </dependency>

    <dependency name='physical'
      grouping='require_all'
      restart_on='error'
      type='service'>
      <service_fmri value='svc:/network/physical:default'/>
    </dependency>

    <dependency name='fs-local'
      grouping='require_all'
      restart_on='none'
      type='service'>
      <service_fmri value='svc:/system/filesystem/local'/>
    </dependency>

    <exec_method
      type='method'
      name='start'
      exec='/opt/puppet/bin/puppet agent'
      timeout_seconds='60' />

    <exec_method
      type='method'
      name='stop'
      exec=':kill'
      timeout_seconds='60' />

    <stability value='Evolving' />

    <template>
      <common_name>
        <loctext xml:lang='C'>Puppet Agent Daemon</loctext>
      </common_name>
      <documentation>
        <manpage title='puppet' section='1' />
        <doc_link name='puppetlabs.com'
          uri='http://puppetlabs.com/puppet/introduction' />
      </documentation>
    </template>
  </service>

</service_bundle>
ENDofSMFxmlCONFIG
                if [ ! -d /etc/puppetlabs ]; then
                    mkdir /etc/puppetlabs
                    chown root:root /etc/puppetlabs
                    chmod 755 /etc/puppetlabs
                fi
                run "svccfg import /var/svc/manifest/network/puppetagent.xml"
                run "svcadm enable svc:/network/puppetagent:default"
                ;;
            *)
                display_failure "Don't know how to start puppet agent service on this platform"
                ;;
        esac
    fi

    if [ y = "${q_puppetdashboard_install?}" ]; then
        display_comment 'Setting up Puppet Dashboard...'
        if [ y = "${q_puppetdashboard_database_install?}" ]; then
            # NONPORTABLE
            case "${PLATFORM_NAME?}" in
                sles )
                    bounce_service 'mysql'
                    enable_service 'mysql'

                    if ! run "mysqladmin -u root password ${q_puppetdashboard_database_root_password:-""} < /dev/null"; then
                        # display_failure "Existing MySQL server found, can't reset its password."
                        display_error "Existing MySQL server found; can't reset its password."
                    fi
                    ;;
                centos | rhel )
                    bounce_service 'mysqld'
                    enable_service 'mysqld'

                    if ! run "mysqladmin -u root password ${q_puppetdashboard_database_root_password:-""} < /dev/null"; then
                        # display_failure "Existing MySQL server found, can't reset its password."
                        display_error "Existing MySQL server found; can't reset its password."
                    fi
                    ;;
                ubuntu | debian)
                    bounce_service 'mysql'
                    enable_service 'mysql'
                    ;;
                *)
                    display_failure "Don't know how to setup MySQL Server on platform: ${PLATFORM_NAME?}"
            esac
            run "echo '
CREATE DATABASE ${q_puppetdashboard_database_name?} CHARACTER SET utf8;
CREATE USER '\\''${q_puppetdashboard_database_user?}'\\''@'\\''localhost'\\'' IDENTIFIED BY '\\''${q_puppetdashboard_database_password?}'\\'';
GRANT ALL PRIVILEGES ON ${q_puppetdashboard_database_name?}.* TO '\\''${q_puppetdashboard_database_user?}'\\''@'\\''localhost'\\'';
GRANT ALL PRIVILEGES ON ${q_puppetdashboard_database_name?}_test.* TO '\\''${q_puppetdashboard_database_user?}'\\''@'\\''localhost'\\'';
' | mysql --user=root --password='${q_puppetdashboard_database_root_password?}'"
        fi

        #...[ database.yml ]....................................................

        t_main__puppetdashboard_database_yml='/etc/puppetlabs/puppet-dashboard/database.yml'
        filebuffer_clear
        filebuffer_append \
"common: &common
    database: ${q_puppetdashboard_database_name?}
    username: ${q_puppetdashboard_database_user?}
    password: ${q_puppetdashboard_database_password?}"

        if [ ! y = "${q_puppetdashboard_database_install?}" ]; then
            if [ y = "${q_puppetdashboard_database_remote?}" ]; then
                filebuffer_append \
"    host: ${q_puppetdashboard_database_host?}
    port: ${q_puppetdashboard_database_port?}"
            fi
        fi

        filebuffer_append \
"    adapter: mysql

development:
    <<: *common

production:
    <<: *common

test:
    database: ${q_puppetdashboard_database_name:-"dashboard"}_test
    <<: *common"
        filebuffer_write "${t_main__puppetdashboard_database_yml?}"

        #...[ puppetdashboard.conf ]............................................

        filebuffer_clear
        filebuffer_append \
"Listen ${q_puppetdashboard_httpd_port?}
<VirtualHost *:${q_puppetdashboard_httpd_port?}>
    DocumentRoot /opt/puppet/share/puppet-dashboard/public
    ErrorLog /var/log/pe-httpd/puppetdashboard.error.log
    TransferLog /var/log/pe-httpd/puppetdashboard.access.log
</VirtualHost>"
        filebuffer_write "/etc/puppetlabs/httpd/conf.d/puppetdashboard.conf"

        #.......................................................................

        if [ y = "${q_puppetdashboard_database_install?}" ]; then
            run 'cd /opt/puppet/share/puppet-dashboard; PATH=/opt/puppet/sbin:/opt/puppet/bin:$PATH rake RAILS_ENV=production db:create'
        fi
        run 'cd /opt/puppet/share/puppet-dashboard; PATH=/opt/puppet/sbin:/opt/puppet/bin:$PATH rake RAILS_ENV=production db:migrate'
    fi

    if [ y = "${q_puppetmaster_install?}" -o y = "${q_puppetdashboard_install?}" ]; then
        display_comment 'Starting Puppet HTTPD for puppet master and/or Puppet Dashboard...'

        if ! is_noop; then
            filebuffer_clear
            filebuffer_append 'PassengerMaxPoolSize 2'
            filebuffer_write "/etc/puppetlabs/httpd/conf.d/passenger-extra.conf"
        fi

        # NONPORTABLE
        case "${PLATFORM_NAME?}" in
            ubuntu | debian)
                # Ubuntu's "pe-httpd" can't cope with ".bak" files.
                run "rm -rf /etc/puppetlabs/httpd/*/*.bak"
                # Ubuntu's "pe-httpd" doesn't enable some important modules by default
                run "/opt/puppet/sbin/a2enmod ssl headers"
                ;;
        esac

        bounce_service 'pe-httpd'
    fi

    install_utils_to_bin

    if [ y = "${q_puppet_symlinks_install?}" ]; then
        display_comment 'Creating symbolic links in "/usr/local/bin"...'
        install_symlink bin/facter bin/puppet bin/puppet-module bin/pe-man
    fi

    #---[ Finish installation ]---------------------------------------------

    run "cp ${INSTALLER_DIR}/VERSION /opt/puppet/pe_version && chown root:root /opt/puppet/pe_version && chmod 644 /opt/puppet/pe_version"

    display_step 'DONE'
    display 'Thanks for installing Puppet Enterprise!'

    display_newline
    display_major_separator

    quit
fi

#===[ End ]=============================================================

# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab
